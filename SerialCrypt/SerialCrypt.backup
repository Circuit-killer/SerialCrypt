#include "SerialCrypt.h"

#define XSWAP(x,y)	(x ^= y ,y = x ^ y , x = x ^ y)
#define MIN(a,b)	(a<b?a:b)

SerialCrypt::SerialCrypt()
{
	init = 0;
}

#ifdef SERIAL_CRYPT_DEBUG
char *SerialCrypt::byteToStr ( uint8_t *data , uint16_t size )
{
	char *ret = (char*)malloc ( (size * 2) + 1 );
	register uint8_t c,m;

	for ( m = c = 0 ; m < size ; m++ , c+=2)
		sprintf(&ret[c],"%02x",data[m]);
	ret[m*2] = 0;

	return ret;
}
#endif

#ifdef SERIAL_CRYPT_DEBUG
void SerialCrypt::_debugCryptCtxt ( struct rc4_state *ctxt )
{
	if ( debug )
	{
		debug->println("");
		debug->print("SBOX: ");
		char *aux = byteToStr ( ctxt->sbox , 128 );
		debug->println(aux);
		free ( aux );
		aux = byteToStr ( &ctxt->sbox[128] , 128 );
		debug->println(aux);
		free ( aux );
		char tmp[17] = {0};
		sprintf(tmp,"i = %d j = %d" , ctxt->i , ctxt->j );
		debug->println(tmp);
	}
}
#endif

void SerialCrypt::test()
{
	uint8_t pass[] = "aaaa";
	uint8_t salida[32] = {0};

	for ( i = 0 ; i < 10 ; i++ )
		buffer[i] = (uint8_t)'a';

	/* key to */
// PBKDF2 ( uint8_t *pass, uint32_t pass_len,
// uint8_t *salt, uint32_t salt_len,
// uint8_t *key, uint32_t key_len,
// uint32_t rounds)
	PBKDF2 ( pass , 1 , buffer , 1 , salida , 10 , 1 );

	debug->println("Salida PBKDF2: ");
		char *aux = byteToStr ( salida , 10 );
		debug->println(aux);
//		free ( aux );


delay(1000000);

#ifdef SERIAL_CRYPT_DEBUG
        if ( debug )
        {
                debug->print("Session Key: ");
                char *aux = byteToStr ( session_key[RANDOM_CLI] , len );
                debug->println(aux);
                free ( aux );
                debug->println("Session established");
        }
#endif
}

void SerialCrypt::_myInit()
{
	test();
    if ( init )
	return;

#ifdef SERIAL_CRYPT_DEBUG
  debug = 0;
#endif

  ok_pin = -1;
  error_pin = -1;
  BigNumber::begin();
  init = 1;
}

void SerialCrypt::SetOKPin ( uint8_t pin )
{
	_myInit();
	ok_pin = (int8_t)pin;
	pinMode ( ok_pin , OUTPUT );
	digitalWrite ( ok_pin , 0 );
}

void SerialCrypt::SetErrorPin ( uint8_t pin )
{
	_myInit();
	error_pin = (int8_t)pin;
	pinMode ( error_pin , OUTPUT );
	digitalWrite ( error_pin , 0 );
}

#ifdef SERIAL_CRYPT_DEBUG
void SerialCrypt::SetSerialDebug ( Stream *ptr )
{
	debug = (Stream*)ptr;
	_myInit();
}
#endif


void SerialCrypt::SetSerial( Stream *s )
{
  _myInit();
  stream = s;
}

void SerialCrypt::begin( BigNumber priv )
{
	poweredOn();
	SendRND();
	RecvRND();
	EstablishDH(priv);
}

void SerialCrypt::invalidHMAC()
{
  if ( ! error_pin < 0 )
	digitalWrite ( error_pin , 245 );

  delay(3000);

  // reset the device
  asm volatile ("jmp 0");
}

void SerialCrypt::correctHMAC()
{
  if ( ! error_pin < 0 )
  {
	digitalWrite ( ok_pin , 245 );
	delay(500);
	digitalWrite ( ok_pin , 0 );
  }
}

void SerialCrypt::poweredOn()
{
  if ( error_pin < 0 && ok_pin < 0 )
	return;

  for ( i = 0 ; i < 3 ; i++ )
  {
    if ( ! error_pin < 0 )
	    digitalWrite ( error_pin , 245 );
    if ( ! ok_pin < 0 )
	    digitalWrite ( ok_pin , 245 );

    delay(500);

    if ( ! error_pin < 0 )
	    digitalWrite ( error_pin , 0 );
    if ( ! ok_pin < 0 )
	    digitalWrite ( ok_pin , 0 );
    delay(200);
  }

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Waked up");
#endif
}

/* from yaSSL (http://www.yassl.com/yaSSL/Source/output/ctaocrypt/src/pwdbased.c.html) */
/*void SerialCrypt::PBKDF2(uint8_t *output, uint8_t *passwd, uint32_t pLen, uint8_t *salt,uint32_t sLen, uint32_t iterations, uint32_t kLen)
{
    uint32_t i = 1;
    int    j;
    uint8_t *mac;


    while (kLen) {
        int currentLen;
    sha1.initHmac ( passwd , pLen );
	sha1.write ( salt , sLen );
        // encode i 
        for (j = 0; j < 4; j++) {
            uint8_t b = (uint8_t)(i >> ((3-j) * 8));
            sha1.write(&b,1);
        }
        currentLen = min(kLen, HMAC_DIGEST_SIZE);
	mac = sha1.result();
        for ( j = 0 ; j < currentLen ; j++ )
		output[j] = mac[j];

        for (j = 1; j < iterations; j++) {
        sha1.initHmac ( passwd , pLen );
            sha1.write ( output , HMAC_DIGEST_SIZE );
            mac = sha1.result();
            for ( i = 0 ; i < currentLen ; i++ )
		output[i] ^= mac[i];
        }

        output += currentLen;
        kLen   -= currentLen;
        i++;
    }
    debug->println("Terminado");
}*/

/*
 * Password-Based Key Derivation Function 2 (PKCS #5 v2.0).
 * Code based on IEEE Std 802.11-2007, Annex H.4.2.
 */
void SerialCrypt::PBKDF2 ( uint8_t *pass, uint32_t pass_len, uint8_t *salt, uint32_t salt_len,uint8_t *key, uint32_t key_len, uint32_t rounds)
{
	uint8_t asalt[HMAC_DIGEST_SIZE + 5], obuf[HMAC_DIGEST_SIZE];
	uint8_t d1[HMAC_DIGEST_SIZE], d2[HMAC_DIGEST_SIZE];
	uint8_t *hmac;
	uint32_t i, j;
	uint32_t count;
	size_t r;

	memcpy(asalt, salt, salt_len);

	for (count = 1; key_len > 0; count++)
	{
		asalt[salt_len + 0] = (count >> 24) & 0xff;
		asalt[salt_len + 1] = (count >> 16) & 0xff;
		asalt[salt_len + 2] = (count >> 8) & 0xff;
		asalt[salt_len + 3] = count & 0xff;

		sha1.initHmac ( pass , pass_len );
		sha1.write ( asalt , salt_len + 4 );
		hmac = sha1.result();

		for ( i = 0 ; i < HMAC_DIGEST_SIZE ; i++ )
			obuf[i] = d1[i] = hmac[i];

		for (i = 1; i < rounds; i++)
		{
			sha1.initHmac ( pass , pass_len );
			sha1.write ( d1 , HMAC_DIGEST_SIZE );
			hmac = sha1.result();

			for ( j = 0 ; j < HMAC_DIGEST_SIZE ; j++ )
				d1[i] = d2[i] = hmac[i];

			for (j = 0; j < HMAC_DIGEST_SIZE ; j++)
				obuf[j] ^= d1[j];
		}

		r = MIN(key_len, HMAC_DIGEST_SIZE);
		for ( i = 0 ; i < r ; i++ )
			key[i] = obuf[i];

		key += r;
		key_len -= r;
	}
}

void SerialCrypt::syncWithRandom()
{
  /* sends random data (for synchronization pourposes only) */
  register uint8_t aux[SYNC_LENGTH] = {0};
  for ( i = 0 ; i < sizeof(aux) ; i++ )
    aux[i] = prng.getRndByte();

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Sync with random bytes");
#endif

    stream->write(aux,sizeof(aux));
}

void SerialCrypt::RC4 ( uint8_t *io , uint32_t len )
{
	RC4 ( &rcvctxt , io , len );
}

void SerialCrypt::RC4 ( struct rc4_state *ctxt , uint8_t *io , uint32_t len )
{
	ctxt->i %= SBOX_LENGTH;
	ctxt->j %= SBOX_LENGTH;
	for ( i = 0 ; i < len ; i++ )
	{
		ctxt->i = (ctxt->i + 1) % SBOX_LENGTH;
		ctxt->j = (ctxt->j + ctxt->sbox[ctxt->i]) % SBOX_LENGTH;
		XSWAP ( ctxt->sbox[ctxt->i] , ctxt->sbox[ctxt->j] );
		io[i] ^= ctxt->sbox[(ctxt->sbox[ctxt->i] + ctxt->sbox[ctxt->j]) % SBOX_LENGTH];
	}
}

void SerialCrypt::SetCryptKey ( uint8_t *key , uint8_t klen )
{
	SetCryptKey ( &sndctxt , key , klen );
	SetCryptKey ( &rcvctxt , key , klen );
}

void SerialCrypt::SetCryptKey ( struct rc4_state *ctxt , uint8_t *key , uint8_t klen )
{
	klen--;

	/* initialize */
	for ( ctxt->i = 0 ; ctxt->i < SBOX_LENGTH ; ctxt->i++ )
		ctxt->sbox[ctxt->i] = ctxt->i;

	ctxt->i = 0;

	/* key schedule algorithm */
	ctxt->j = 0;
	for ( ctxt->i = 0 ; ctxt->i < SBOX_LENGTH ; ctxt->i++ )
	{
		ctxt->j = (ctxt->j + ctxt->sbox[ctxt->i] + key[ctxt->i % klen]) % SBOX_LENGTH;
		XSWAP ( ctxt->sbox[ctxt->i] , ctxt->sbox[ctxt->j] );
	}
	ctxt->i = ctxt->j = 0;
}

void SerialCrypt::SetHMACKey ( uint8_t *key , uint8_t len )
{
#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Setting HMAC key");
#endif
	hmac_key = key;
	hmac_klen = len;
}

void SerialCrypt::sendCrypt ( uint32_t dlen )
{
	sendCrypt ( &sndctxt , dlen );
}

void SerialCrypt::sendCrypt ( uint8_t *data , uint32_t dlen )
{
	for ( i = 0 ; i < dlen ; i++ )
		buffer[i] = data[i];

	sendCrypt(dlen);
}

void SerialCrypt::sendCrypt ( struct rc4_state *ctxt , uint32_t dlen )
{
  register uint32_t tlen;

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
	{
		debug->println("");
		debug->print("    PLAIN: ");
		char *aux = byteToStr ( buffer , dlen );
		debug->println(aux);
		free ( aux );
	}
#endif

  /* encrypt data */
  RC4 ( ctxt , buffer , dlen );

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
	{
		debug->print("    ENCRYPTED: ");
		char *aux = byteToStr ( buffer , dlen );
		debug->println(aux);
		free ( aux );
	}
#endif

  /* generates the HMAC of the ciphertext */
  sha1.initHmac(hmac_key,hmac_klen);
  sha1.write(buffer,dlen);
  hmac = sha1.resultHmac();

  /* concatenate ciphertext and HMAC */
  for ( i = 0 ; i < HMAC_DIGEST_SIZE ; i++ )
    buffer[dlen+i] = hmac[i];
  dlen += HMAC_DIGEST_SIZE;

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
	{
		debug->print("    HMAC: ");
		char *aux = byteToStr ( hmac , HMAC_DIGEST_SIZE );
		debug->println(aux);
		free ( aux );

		debug->print("    CIPHERTEXT: ");
		aux = byteToStr ( buffer , dlen );
		debug->println(aux);
		free ( aux );
	}
#endif

  tlen = base64_encode ( (char*)b64 , (char*)buffer , dlen );

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
	{
		debug->print("    Encoded: ");
		debug->println((char*)b64);
		debug->println("");
	}
#endif

	stream->write(b64,tlen);
}


uint32_t SerialCrypt::recvCrypt ()
{
	recvCrypt ( &rcvctxt );
}

uint32_t SerialCrypt::recvCrypt ( uint8_t *data , uint32_t dlen )
{
	register uint32_t ret = recvCrypt(&rcvctxt);
	for ( i = 0 ; i < ret && i < dlen ; i++ )
		data[i] = buffer[i];
}

uint32_t SerialCrypt::recvCrypt ( struct rc4_state *ctxt )
{
	register uint32_t b;
	register uint8_t cont = 0;

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println ( "" );
#endif

	  while ( ! stream->available() );
	  for ( i = 1 ; i <= BUFFER_LENGTH && ( stream->available() || b64[i-1] != 0 ) ; i++ )
	  {
		while ( ! stream->available() && cont < 3 )
		{
			delay(500);
			cont++;
		}

		if ( cont >= 3 )
			break;
		b64[i-1] = stream->read();
	  }
	  /* buffer is too short but there is data to be readed */
	  while ( stream->available() )
	    stream->read();

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
	{
		debug->print("    Encoded: ");
		debug->println((char*)b64);
		delay(2000);
	}
#endif

  /* decode Base64 */
  i = base64_decode ( (char*)buffer , (char*)b64 , i - 1 );

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
	{
		debug->print("    Encrypted: ");
		char *aux = byteToStr ( buffer , i );
		debug->println(aux);
		free ( aux );
		delay(2000);
	}
#endif

	b = i - HMAC_DIGEST_SIZE;
#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
	{
		debug->print("    HMAC: ");
		char *aux = byteToStr ( &buffer[b] , HMAC_DIGEST_SIZE );
		debug->println(aux);
		free ( aux );
		delay(3000);
	}
#endif

  /* generate HMAC */
  sha1.initHmac(hmac_key,hmac_klen);
  sha1.write(buffer,b);
  hmac = sha1.resultHmac();

  /* verify HMAC */
  for ( j = b ; j < b + HMAC_DIGEST_SIZE - 1; j++ );
    if ( (buffer[j] ^ hmac[j - b ]) != 0 )
      invalidHMAC();

  correctHMAC();

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
	{
		debug->print("    ENCRYPTED: ");
		char *aux = byteToStr ( buffer , b );
		debug->println(aux);
		free ( aux );
	}
#endif

  /* decrypt data */
  RC4 ( ctxt , buffer, b );

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
	{
		debug->print("    PLAIN: ");
		char *aux = byteToStr ( buffer , b );
		debug->println(aux);
		free ( aux );
		debug->println ( "" );
	}
#endif

  return b;
}

void SerialCrypt::SendRND()
{
#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Waitting for signal");
#endif

	/* wait until signal is received */
	while ( ! stream->available() )
		delay ( 10 );
	stream->read();

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Generating RND0");
#endif

  /* generate RND0 */
  for ( i = 0 ; i < RANDOM_LENGTH ; i++ )
	buffer[i] = rnd[RANDOM_DEV][i] = prng.getRndByte();

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Sending RND0");
#endif

  /* send RND0 */
  sendCrypt ( RANDOM_LENGTH );
}

void SerialCrypt::RecvRND()
{
#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Receiveing RND1");
#endif

  /* recv RND1 */
  len = recvCrypt ();

  for ( i = 0 ; i < len && i < RANDOM_LENGTH ; i++ )
    rnd[RANDOM_CLI][i] = buffer[i];

  syncWithRandom();
}

void SerialCrypt::EstablishDH(BigNumber privKey )
{
   BigNumber pk;

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Receiveing DH Generator");
#endif


#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
	{
		debug->print("Downstream Key: ");
		char *aux = byteToStr ( rnd[RANDOM_CLI] , RANDOM_LENGTH );
		debug->println(aux);
		free ( aux );
		debug->print("Upstream Key: ");
		aux = byteToStr ( rnd[RANDOM_DEV] , RANDOM_LENGTH );
		debug->println(aux);
		free ( aux );
		debug->println ( "" );
	}
#endif

  /* receive DH Generator */
  SetCryptKey ( &rcvctxt , rnd[RANDOM_CLI] , RANDOM_LENGTH + 1);
  len = recvCrypt();

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Converting DH Generator to BigNumber");
#endif

  /* convert DH generator to BigNumber */
  dhtmp = (char*)malloc ( len );
  for ( i = 0 ; i < len ; i++ )
    dhtmp[i] = buffer[i];
  g = BigNumber(dhtmp);
  free ( dhtmp );
  syncWithRandom();

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Receiveing DH Prime");
#endif

  /* receive DH Prime */
  len = recvCrypt ();

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Converting DH Prime to BigNumber");
#endif

  /* convert DH prime to BigNumber */
  dhtmp = (char*)malloc ( len );
  for ( i = 0 ; i < len ; i++ )
    dhtmp[i] = buffer[i];
  p = BigNumber(dhtmp);
  free ( dhtmp );

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Calculating device's public key");
#endif

  /* calculate public key */
  pk = g.powMod(p,privKey);
  dhtmp = pk.toString();

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Sending device's public key");
#endif

  /* send DH public key */
  len = strlen(dhtmp);
  for ( i = 0 ; i < len ; i++ )
    buffer[i] = dhtmp[i];
  SetCryptKey ( &sndctxt,rnd[RANDOM_DEV] , RANDOM_LENGTH + 1);
  sendCrypt ( len );

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Receiveing peer's public key");
#endif

  /* receive public key */
  len = recvCrypt ();

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Converting peer's public key to BigNumber");
#endif

  /* convert public key to BigNumber */
  dhtmp = (char*)malloc ( len );
  pk = 0;
  for ( i = 0 ; i < len ; i++ )
    dhtmp[i] = buffer[i];
  pk = BigNumber(dhtmp);

#ifdef SERIAL_CRYPT_DEBUG
	if ( debug )
		debug->println("Calculating session key");
#endif

  /* calculate the initial session key */
  dhtmp = pk.powMod(privKey,p).toString();
  len = strlen(dhtmp);
  memset ( buffer , 0 , BUFFER_LENGTH );
  for ( i = 0 ; i < len ; i++ )
    buffer[i] = dhtmp[i];
  free ( dhtmp );

  /* key to */
  //PBKDF2 ( session_key [ RANDOM_CLI ] , buffer , i , PBKDF2_ITERATIONS , RANDOM_LENGTH );
  SetCryptKey ( &rcvctxt , session_key[RANDOM_CLI] , RANDOM_LENGTH );

#ifdef SERIAL_CRYPT_DEBUG
        if ( debug )
        {
                debug->print("Session Key: ");
                char *aux = byteToStr ( session_key[RANDOM_CLI] , len );
		debug->println(aux);
                free ( aux );
		debug->println("Session established");
	}
#endif

}
